                                       Question Application:
Clone the below mentioned repository and deploy the application (Run application in port 3000).
Repo URL : https://github.com/Vennilavan12/Trend.git

Docker:
Dockerize the application by creating Dockerfile
Build an application and check output using docker image.

Terraform:
Define infrastructure in main.tf to create VPC, IAM, EC2 with Jenkins, etc.
Use terraform command to provision infrastructure.
DockerHub:                                       Question Application:
Clone the below mentioned repository and deploy the application (Run application in port 3000).
Repo URL : https://github.com/Vennilavan12/Trend.git

Docker:
Dockerize the application by creating Dockerfile
Build an application and check output using docker image.

Terraform:
Define infrastructure in main.tf to create VPC, IAM, EC2 with Jenkins, etc.
Use terraform command to provision infrastructure.
DockerHub:
Create a DockerHub repository.
Kubernetes:
Setup Kubernetes in AWS EKS and Confirm EKS cluster is running.
Write deployment and service YAML files.
Deploy using kubectl via Jenkins.
Version Control:
Push the codebase to a Git provider (GitHub).
Add gitignore and dockerignore files and use CLI commands to push code.
Jenkins: 
Install Jenkins and necessary plugins (Docker, Git, Kubernetes, Pipeline) for build, push &deploy applications.
Setup Github and jenkins integration using github webhook build trigger for auto build for every commit.
Create a declarative pipeline script and pipeline project to build, push & deploy using CI-CD.
Monitoring:
Setup a monitoring system to check the health of the cluster or application (opensource) is highly appreciable. 
Submission Guidelines:
GitHub Link: Submit full code repository.
README File: Include setup instructions, pipeline explanation, and screenshots or create a document and attach all screenshots.
Application deployed kubernetes Loadbalancer ARN.

**************************************************************************************************************************
terraform file for ctreate the ec2 instance :
create folder terraform and create file main.tf
copy and paste follwing contnent

nano main.tf

provider "aws" {
  region = "us-east-1"
}

# ---------------------------------------
# Auto-generate SSH Key Pair for EC2
# ---------------------------------------
resource "tls_private_key" "auto_key" {
  algorithm = "RSA"
  rsa_bits  = 4096
}

resource "aws_key_pair" "auto_keypair" {
  key_name   = "ubuntu-devops-key"
  public_key = tls_private_key.auto_key.public_key_openssh
}

output "private_key_pem" {
  value     = tls_private_key.auto_key.private_key_pem
  sensitive = true
}

# ---------------------------------------
# Security Group with all required ports
# ---------------------------------------
resource "aws_security_group" "devops_sg" {
  name        = "ubuntu-devops-sg"
  description = "Allow DevOps ports"

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 8080
    to_port     = 8080
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 3000
    to_port     = 3000
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 3306
    to_port     = 3306
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 9090
    to_port     = 9090
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 9100
    to_port     = 9100
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 9323
    to_port     = 9323
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# ---------------------------------------
# Ubuntu EC2 Instance with Java 21, Jenkins, Docker
# ---------------------------------------
resource "aws_instance" "ubuntu_ec2" {
  ami                         = "ami-0fc5d935ebf8bc3bc" # Ubuntu 22.04 in us-east-1
  instance_type               = "t3.medium"
  key_name                    = aws_key_pair.auto_keypair.key_name
  vpc_security_group_ids      = [aws_security_group.devops_sg.id]

  user_data = <<-EOF
              #!/bin/bash
              apt-get update -y
              apt-get install -y wget gnupg curl unzip

              # Install Java 21 (OpenJDK)
              add-apt-repository ppa:openjdk-r/ppa -y
              apt-get update
              apt-get install -y openjdk-21-jdk

              # Set JAVA_HOME
              echo 'export JAVA_HOME=$(dirname $(dirname $(readlink -f $(which javac))))' >> /etc/profile
              echo 'export PATH=$JAVA_HOME/bin:$PATH' >> /etc/profile
              source /etc/profile

              # Install Docker
              apt-get install -y docker.io
              systemctl start docker
              systemctl enable docker
              usermod -aG docker ubuntu
              chmod 777 /var/run/docker.sock

              # Install Jenkins
              curl -fsSL https://pkg.jenkins.io/debian/jenkins.io.key | tee \
                /usr/share/keyrings/jenkins-keyring.asc > /dev/null
              echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
                https://pkg.jenkins.io/debian binary/ | tee \
                /etc/apt/sources.list.d/jenkins.list > /dev/null

              apt-get update
              apt-get install -y jenkins
              systemctl enable jenkins
              systemctl start jenkins
              EOF

  tags = {
    Name = "Ubuntu-DevOps-Server"
  }
}


run the file by using follwing command:
terraform init
terraform plan
terraform apply

after creation login into ec2 instance
to check all packages installed or not by using command:

sudo cat /var/log/cloud-init-output.log


after that configure the jenkins:
 1. run the jenkins by using http://yourec2ip:8080
 2.Retrieve initial admin password (only first time):
 sudo cat /var/lib/jenkins/secrets/initialAdminPassword
 3.Install suggested plugins when prompted (“Install suggested plugins”). If you skip, you can install later via Manage Jenkins → Manage Plugins.
 4.Required Plugins (ensure these are installed):
 
GitHub Plugin

Git Plugin

Pipeline (Workflow) Plugin

Docker Plugin

Kubernetes CLI Plugin (or just ensure kubectl is installed on agent)

Credentials Binding Plugin

Amazon EKS / AWS CLI support (can be handled via shell steps)

5. Credentials Setup in Jenkins:

Go to Credentials → System → Global credentials (unrestricted) → Add Credentials.

Add the following:

DockerHub credentials

Kind: Username with password

ID: e.g., dockerhub-creds

Username: your DockerHub username

Password: DockerHub password or access token

GitHub access token (if the repo is private or to avoid rate limits)

Kind: Secret text (or username/password if using username + PAT)

ID: e.g., github-token

Token: Generated from GitHub (with repo, admin:repo_hook scopes if needing webhook setup)

AWS credentials (if you're using aws CLI in the pipeline to talk to EKS)

Kind: AWS Credentials (if using AWS Credentials Plugin) or “Username with password”/secret text to set AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY

ID: e.g., aws-creds

Kubeconfig (optional alternative)

Store kubeconfig content as a secret file and write it to disk in the pipeline step before running kubectl.


Run the Docker container:
create and save the docker file in source code folder:

nano Dockerfile

#copy the content:

# Use Nginx base image
FROM nginx:alpine

# Remove default Nginx static files
RUN rm -rf /usr/share/nginx/html/*

# Copy all current static files into Nginx html directory
COPY . /usr/share/nginx/html

# Set permissions (optional but helpful)
RUN chmod -R 755 /usr/share/nginx/html

# Expose port 80
EXPOSE 80

# Start Nginx in foreground
CMD ["nginx", "-g", "daemon off;"]

Create Docker registory:

docker login -u your docker id
enter your password

docker tag trendify-app yourdockerhubuser/trendify-app:latest

docker tag trendify-app aravinddev/trendify-app:latest

Push to Docker Hub:
docker push aravinthdevops/trendify-app:latest(yourdockerhubuser)

Pull the Image:
docker pull aravinthdevops/trendify-app:latest(yourdockerhubuser)

Run the Container:
docker run -d -p 3000:80 --name trendify-container aravinthdevops/trendify-app:latest(yourdockerhubuser)

Verify Container is Running:
dokcer ps

Test in Browser:

AWS EC2: http://<your-ec2-public-ip>:3000
(Ensure port 3000 is open in the EC2 Security Group)

Stop & Remove Container (if needed):
docker stop trendify-container
docker rm trendify-container

Install aws configure
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
aws --version



login aws configure :
aws configure

install eksctl :

Create EKS Cluster with ekctl:

KUBECTL_VERSION="v1.30.1"
curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin/
kubectl version --client



Command to create EKS cluster:
eksctl create cluster \
  --name trendify-cluster \
  --region us-east-1 \
  --version 1.30 \
  --nodegroup-name standard-nodes \
  --node-type t3.medium \
  --nodes 1 \
  --nodes-min 1 \
  --nodes-max 2 \
  --managed \
  --with-oidc \
  --ssh-access \
  --ssh-public-key my-eks-key(your-ec2-key-name: with your EC2 Key Pair name)
  
  After Cluster Creation: Configure kubectl:
  
  aws eks update-kubeconfig --region us-east-1 --name trendify-cluster-1


Then test:

kubectl get nodes

to remove the cluster:

eksctl delete cluster --name trendify-cluster-1 --region us-east-1

aws eks list-clusters --region us-east-1


jenkins file:

pipeline {
  agent any

  environment {
    AWS_REGION = "us-east-1"
    CLUSTER_NAME = "trendify-cluster-1"
    IMAGE_NAME = "aravinthdevops/trendmine"
  }

  stages {
    stage('Checkout Code') {
      steps {
        git branch: 'master', url: 'https://github.com/aravinthhub7/trendmine.git'
        script {
          // Save short Git commit hash globally for image tagging
          env.GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
        }
      }
    }

    stage('Build Docker Image') {
      steps {
        script {
          // Build using Dockerfile in the ./dist folder
          sh "docker build -t ${IMAGE_NAME}:${GIT_COMMIT_SHORT} ./dist"
        }
      }
    }

    stage('Push to DockerHub') {
      environment {
        DOCKER_CREDENTIALS = credentials('dockerhub-creds') 
      }
      steps {
        sh '''
          echo $DOCKER_CREDENTIALS_PSW | docker login -u $DOCKER_CREDENTIALS_USR --password-stdin
          docker push ${IMAGE_NAME}:${GIT_COMMIT_SHORT}
        '''
      }
    }

    stage('Configure kubectl for EKS') {
      environment {
        AWS_CREDS = credentials('aws-creds') 
      }
      steps {
        sh '''
          mkdir -p ~/.aws
          echo "[default]" > ~/.aws/credentials
          echo "aws_access_key_id=$AWS_CREDS_USR" >> ~/.aws/credentials
          echo "aws_secret_access_key=$AWS_CREDS_PSW" >> ~/.aws/credentials

          echo "[default]" > ~/.aws/config
          echo "region=${AWS_REGION}" >> ~/.aws/config

          aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
        '''
      }
    }

    stage('Deploy to EKS') {
      steps {
        sh '''
          echo "Current Directory:"
          pwd
          echo "Listing Files:"
          ls -R

          echo " Deploying to EKS..."
          kubectl apply -f k8s/deployment.yml
          kubectl apply -f k8s/service.yml

          echo "Updating image in deployment..."
          kubectl set image deployment/trendmine-deployment trendmine=${IMAGE_NAME}:${GIT_COMMIT_SHORT} --record

          echo " Waiting for rollout to complete..."
          kubectl rollout status deployment/trendmine-deployment
        '''
      }
    }
  }

  post {
    failure {
      echo ' Build or deployment failed.'
    }
    success {
      echo " Application deployed successfully: ${IMAGE_NAME}:${GIT_COMMIT_SHORT}"
    }
  }
}
 Check Deployment & Pods in EKS:


# Check deployments
kubectl get deployments



# Check pods
kubectl get pods

# Check services (to get the LoadBalancer or NodePort)
kubectl get svc

Open that EXTERNAL-IP (or ELB URL) in your browser to see your app live


Prometheus + Grafana:

Install Helm (if not installed)

curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
Verify:
helm version
Add Prometheus Community Helm repo
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update

Get Grafana admin password
kubectl get secret --namespace monitoring kube-prometheus-stack-grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo
kubectl create namespace monitoring

Access Grafana Dashboard
kubectl edit svc -n monitoring kube-prometheus-stack-grafana
kubectl get svc -n monitoring kube-prometheus-stack-grafana
Username: admin

Password: copy the admin password

View Dashboards

 To Uninstall
 
helm uninstall kube-prometheus-stack --namespace monitoring
kubectl delete namespace monitoring

Create a DockerHub repository.
Kubernetes:
Setup Kubernetes in AWS EKS and Confirm EKS cluster is running.
Write deployment and service YAML files.
Deploy using kubectl via Jenkins.
Version Control:
Push the codebase to a Git provider (GitHub).
Add gitignore and dockerignore files and use CLI commands to push code.
Jenkins: 
Install Jenkins and necessary plugins (Docker, Git, Kubernetes, Pipeline) for build, push &deploy applications.
Setup Github and jenkins integration using github webhook build trigger for auto build for every commit.
Create a declarative pipeline script and pipeline project to build, push & deploy using CI-CD.
Monitoring:
Setup a monitoring system to check the health of the cluster or application (opensource) is highly appreciable. 
Submission Guidelines:
GitHub Link: Submit full code repository.
README File: Include setup instructions, pipeline explanation, and screenshots or create a document and attach all screenshots.
Application deployed kubernetes Loadbalancer ARN.

**************************************************************************************************************************
terraform file for ctreate the ec2 instance :
create folder terraform and create file main.tf
copy and paste follwing contnent

nano main.tf

provider "aws" {
  region = "us-east-1"
}

# ---------------------------------------
# Auto-generate SSH Key Pair for EC2
# ---------------------------------------
resource "tls_private_key" "auto_key" {
  algorithm = "RSA"
  rsa_bits  = 4096
}

resource "aws_key_pair" "auto_keypair" {
  key_name   = "ubuntu-devops-key"
  public_key = tls_private_key.auto_key.public_key_openssh
}

output "private_key_pem" {
  value     = tls_private_key.auto_key.private_key_pem
  sensitive = true
}

# ---------------------------------------
# Security Group with all required ports
# ---------------------------------------
resource "aws_security_group" "devops_sg" {
  name        = "ubuntu-devops-sg"
  description = "Allow DevOps ports"

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 8080
    to_port     = 8080
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 3000
    to_port     = 3000
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 3306
    to_port     = 3306
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 9090
    to_port     = 9090
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 9100
    to_port     = 9100
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 9323
    to_port     = 9323
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# ---------------------------------------
# Ubuntu EC2 Instance with Java 21, Jenkins, Docker
# ---------------------------------------
resource "aws_instance" "ubuntu_ec2" {
  ami                         = "ami-0fc5d935ebf8bc3bc" # Ubuntu 22.04 in us-east-1
  instance_type               = "t2.micro"
  key_name                    = aws_key_pair.auto_keypair.key_name
  vpc_security_group_ids      = [aws_security_group.devops_sg.id]

  user_data = <<-EOF
              #!/bin/bash
              apt-get update -y
              apt-get install -y wget gnupg curl unzip

              # Install Java 21 (OpenJDK)
              add-apt-repository ppa:openjdk-r/ppa -y
              apt-get update
              apt-get install -y openjdk-21-jdk

              # Set JAVA_HOME
              echo 'export JAVA_HOME=$(dirname $(dirname $(readlink -f $(which javac))))' >> /etc/profile
              echo 'export PATH=$JAVA_HOME/bin:$PATH' >> /etc/profile
              source /etc/profile

              # Install Docker
              apt-get install -y docker.io
              systemctl start docker
              systemctl enable docker
              usermod -aG docker ubuntu
              chmod 777 /var/run/docker.sock

              # Install Jenkins
              curl -fsSL https://pkg.jenkins.io/debian/jenkins.io.key | tee \
                /usr/share/keyrings/jenkins-keyring.asc > /dev/null
              echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
                https://pkg.jenkins.io/debian binary/ | tee \
                /etc/apt/sources.list.d/jenkins.list > /dev/null

              apt-get update
              apt-get install -y jenkins
              systemctl enable jenkins
              systemctl start jenkins
              EOF

  tags = {
    Name = "Ubuntu-DevOps-Server"
  }
}


run the file by using follwing command:
terraform init
terraform plan
terraform apply

after creation login into ec2 instance
to check all packages installed or not by using command:

sudo cat /var/log/cloud-init-output.log


after that configure the jenkins:
 1. run the jenkins by using http://yourec2ip:8080
 2.Retrieve initial admin password (only first time):
 sudo cat /var/lib/jenkins/secrets/initialAdminPassword
 3.Install suggested plugins when prompted (“Install suggested plugins”). If you skip, you can install later via Manage Jenkins → Manage Plugins.
 4.Required Plugins (ensure these are installed):
 
GitHub Plugin

Git Plugin

Pipeline (Workflow) Plugin

Docker Plugin

Kubernetes CLI Plugin (or just ensure kubectl is installed on agent)

Credentials Binding Plugin

Amazon EKS / AWS CLI support (can be handled via shell steps)

5. Credentials Setup in Jenkins:

Go to Credentials → System → Global credentials (unrestricted) → Add Credentials.

Add the following:

DockerHub credentials

Kind: Username with password

ID: e.g., dockerhub-creds

Username: your DockerHub username

Password: DockerHub password or access token

GitHub access token (if the repo is private or to avoid rate limits)

Kind: Secret text (or username/password if using username + PAT)

ID: e.g., github-token

Token: Generated from GitHub (with repo, admin:repo_hook scopes if needing webhook setup)

AWS credentials (if you're using aws CLI in the pipeline to talk to EKS)

Kind: AWS Credentials (if using AWS Credentials Plugin) or “Username with password”/secret text to set AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY

ID: e.g., aws-creds

Kubeconfig (optional alternative)

Store kubeconfig content as a secret file and write it to disk in the pipeline step before running kubectl.


Run the Docker container:
create and save the docker file in source code folder:

nano Dockerfile

#copy the content:

# Use Nginx base image
FROM nginx:alpine

# Remove default Nginx static files
RUN rm -rf /usr/share/nginx/html/*

# Copy all current static files into Nginx html directory
COPY . /usr/share/nginx/html

# Set permissions (optional but helpful)
RUN chmod -R 755 /usr/share/nginx/html

# Expose port 80
EXPOSE 80

# Start Nginx in foreground
CMD ["nginx", "-g", "daemon off;"]

Create Docker registory:

docker login -u your docker id
enter your password

docker tag trendify-app yourdockerhubuser/trendify-app:latest

docker tag trendify-app aravinddev/trendify-app:latest

Push to Docker Hub:
docker push yourdockerhubuser/trendify-app:latest

Pull the Image:
docker pull yourdockerhubuser/trendify-app:latest

Run the Container:
docker run -d -p 3000:80 --name trendify-container yourdockerhubuser/trendify-app:latest

Verify Container is Running:
dokcer ps

Test in Browser:

AWS EC2: http://<your-ec2-public-ip>:3000
(Ensure port 3000 is open in the EC2 Security Group)

Stop & Remove Container (if needed):
docker stop trendify-container
docker rm trendify-container

Install aws configure
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
sudo apt install awscli

login aws configure :
aws configure

Create EKS Cluster with ekctl:

curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
chmod +x kubectl
sudo mv /tmp/eksctl /usr/local/bin/
kubectl version --client



Command to create EKS cluster:
eksctl create cluster \
  --name trendify-cluster \
  --region us-east-1 \
  --nodegroup-name standard-nodes \
  --node-type t3.small \
  --nodes 1 \
  --nodes-min 1 \
  --nodes-max 2 \
  --managed \
  --with-oidc \
  --ssh-access \
  --ssh-public-key your-ec2-key-name(your-ec2-key-name: with your EC2 Key Pair name)
  
  After Cluster Creation: Configure kubectl:
  
  aws eks update-kubeconfig --region us-east-1 --name trendify-cluster


Then test:

kubectl get nodes

to remove the cluster:

eksctl delete cluster --name trendify-cluster --region us-east-1

aws eks list-clusters --region us-east-1


jenkins file:

pipeline {
  agent any

  environment {
    AWS_REGION = "us-east-1"
    CLUSTER_NAME = "trendify-cluster"
    IMAGE_NAME = "aravinthdevops/trendmine"
    GIT_COMMIT_SHORT = ""
  }

  stages {
    stage('Checkout Code') {
      steps {
        git branch: 'main', url: 'https://github.com/aravinthhub7/trendmine.git'
        script {
          GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
        }
      }
    }

    stage('Build Docker Image') {
      steps {
        script {
          sh "docker build -t ${IMAGE_NAME}:${GIT_COMMIT_SHORT} ."
        }
      }
    }

    stage('Push to DockerHub') {
      environment {
        DOCKER_CREDENTIALS = credentials('dockerhub-creds') 
      }
      steps {
        sh '''
          echo $DOCKER_CREDENTIALS_PSW | docker login -u $DOCKER_CREDENTIALS_USR --password-stdin
          docker push ${IMAGE_NAME}:${GIT_COMMIT_SHORT}
        '''
      }
    }

    stage('Configure kubectl for EKS') {
      environment {
        AWS_CREDS = credentials('aws-creds') 
      }
      steps {
        sh '''
          export AWS_ACCESS_KEY_ID=$AWS_CREDS_USR
          export AWS_SECRET_ACCESS_KEY=$AWS_CREDS_PSW
          aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
        '''
      }
    }

    stage('Deploy to EKS') {
      steps {
        sh '''
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml
          kubectl set image deployment/trendmine-deployment trendmine=${IMAGE_NAME}:${GIT_COMMIT_SHORT} --record
          kubectl rollout status deployment/trendmine-deployment
        '''
      }
    }
  }

  post {
    failure {
      echo 'Build or deployment failed.'
    }
    success {
      echo "Application deployed successfully at ${IMAGE_NAME}:${GIT_COMMIT_SHORT}"
    }
  }
}










